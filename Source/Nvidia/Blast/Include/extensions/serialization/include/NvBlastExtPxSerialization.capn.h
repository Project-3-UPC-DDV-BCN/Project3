// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: NvBlastExtPxSerialization.capn

#ifndef CAPNP_INCLUDED_f4df9a42d5842b01_
#define CAPNP_INCLUDED_f4df9a42d5842b01_

#include <capnp/generated-header-support.h>

#if CAPNP_VERSION != 6001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "NvBlastExtTkSerialization.capn.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e67e9b52a4f4c5dc);
CAPNP_DECLARE_SCHEMA(920ebb03da744765);
CAPNP_DECLARE_SCHEMA(864211458400770e);
CAPNP_DECLARE_SCHEMA(adae9deb89212865);
CAPNP_DECLARE_SCHEMA(b197145e18e8b82a);
enum class Type_b197145e18e8b82a: uint16_t {
  E_S_P_H_E_R_E,
  E_P_L_A_N_E,
  E_C_A_P_S_U_L_E,
  E_B_O_X,
  E_C_O_N_V_E_X_M_E_S_H,
  E_T_R_I_A_N_G_L_E_M_E_S_H,
  E_H_E_I_G_H_T_F_I_E_L_D,
};
CAPNP_DECLARE_ENUM(Type, b197145e18e8b82a);
CAPNP_DECLARE_SCHEMA(aea6c3ede69b9227);
CAPNP_DECLARE_SCHEMA(d9e85646bf529a45);
CAPNP_DECLARE_SCHEMA(fe3844eab62f741c);

}  // namespace schemas
}  // namespace capnp

namespace Nv {
namespace Blast {
namespace Serialization {

struct ExtPxAsset {
  ExtPxAsset() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e67e9b52a4f4c5dc, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ExtPxChunk {
  ExtPxChunk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(920ebb03da744765, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct ExtPxSubchunk {
  ExtPxSubchunk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(864211458400770e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PxConvexMeshGeometry {
  PxConvexMeshGeometry() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_b197145e18e8b82a Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adae9deb89212865, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PxQuat {
  PxQuat() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aea6c3ede69b9227, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PxMeshScale {
  PxMeshScale() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d9e85646bf529a45, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PxTransform {
  PxTransform() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fe3844eab62f741c, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class ExtPxAsset::Reader {
public:
  typedef ExtPxAsset Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAsset() const;
  inline  ::Nv::Blast::Serialization::TkAsset::Reader getAsset() const;

  inline bool hasChunks() const;
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Reader getChunks() const;

  inline bool hasSubchunks() const;
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Reader getSubchunks() const;

  inline float getUniformInitialBondHealth() const;

  inline bool hasBondHealths() const;
  inline  ::capnp::List<float>::Reader getBondHealths() const;

  inline float getUniformInitialLowerSupportChunkHealth() const;

  inline bool hasSupportChunkHealths() const;
  inline  ::capnp::List<float>::Reader getSupportChunkHealths() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ExtPxAsset::Builder {
public:
  typedef ExtPxAsset Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAsset();
  inline  ::Nv::Blast::Serialization::TkAsset::Builder getAsset();
  inline void setAsset( ::Nv::Blast::Serialization::TkAsset::Reader value);
  inline  ::Nv::Blast::Serialization::TkAsset::Builder initAsset();
  inline void adoptAsset(::capnp::Orphan< ::Nv::Blast::Serialization::TkAsset>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::TkAsset> disownAsset();

  inline bool hasChunks();
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Builder getChunks();
  inline void setChunks( ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Reader value);
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Builder initChunks(unsigned int size);
  inline void adoptChunks(::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>> disownChunks();

  inline bool hasSubchunks();
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Builder getSubchunks();
  inline void setSubchunks( ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Reader value);
  inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Builder initSubchunks(unsigned int size);
  inline void adoptSubchunks(::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>> disownSubchunks();

  inline float getUniformInitialBondHealth();
  inline void setUniformInitialBondHealth(float value);

  inline bool hasBondHealths();
  inline  ::capnp::List<float>::Builder getBondHealths();
  inline void setBondHealths( ::capnp::List<float>::Reader value);
  inline void setBondHealths(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float>::Builder initBondHealths(unsigned int size);
  inline void adoptBondHealths(::capnp::Orphan< ::capnp::List<float>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float>> disownBondHealths();

  inline float getUniformInitialLowerSupportChunkHealth();
  inline void setUniformInitialLowerSupportChunkHealth(float value);

  inline bool hasSupportChunkHealths();
  inline  ::capnp::List<float>::Builder getSupportChunkHealths();
  inline void setSupportChunkHealths( ::capnp::List<float>::Reader value);
  inline void setSupportChunkHealths(::kj::ArrayPtr<const float> value);
  inline  ::capnp::List<float>::Builder initSupportChunkHealths(unsigned int size);
  inline void adoptSupportChunkHealths(::capnp::Orphan< ::capnp::List<float>>&& value);
  inline ::capnp::Orphan< ::capnp::List<float>> disownSupportChunkHealths();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ExtPxAsset::Pipeline {
public:
  typedef ExtPxAsset Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Nv::Blast::Serialization::TkAsset::Pipeline getAsset();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ExtPxChunk::Reader {
public:
  typedef ExtPxChunk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getFirstSubchunkIndex() const;

  inline  ::uint32_t getSubchunkCount() const;

  inline bool getIsStatic() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ExtPxChunk::Builder {
public:
  typedef ExtPxChunk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint32_t getFirstSubchunkIndex();
  inline void setFirstSubchunkIndex( ::uint32_t value);

  inline  ::uint32_t getSubchunkCount();
  inline void setSubchunkCount( ::uint32_t value);

  inline bool getIsStatic();
  inline void setIsStatic(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ExtPxChunk::Pipeline {
public:
  typedef ExtPxChunk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class ExtPxSubchunk::Reader {
public:
  typedef ExtPxSubchunk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTransform() const;
  inline  ::Nv::Blast::Serialization::PxTransform::Reader getTransform() const;

  inline bool hasGeometry() const;
  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Reader getGeometry() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class ExtPxSubchunk::Builder {
public:
  typedef ExtPxSubchunk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTransform();
  inline  ::Nv::Blast::Serialization::PxTransform::Builder getTransform();
  inline void setTransform( ::Nv::Blast::Serialization::PxTransform::Reader value);
  inline  ::Nv::Blast::Serialization::PxTransform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::Nv::Blast::Serialization::PxTransform>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxTransform> disownTransform();

  inline bool hasGeometry();
  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Builder getGeometry();
  inline void setGeometry( ::Nv::Blast::Serialization::PxConvexMeshGeometry::Reader value);
  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Builder initGeometry();
  inline void adoptGeometry(::capnp::Orphan< ::Nv::Blast::Serialization::PxConvexMeshGeometry>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxConvexMeshGeometry> disownGeometry();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class ExtPxSubchunk::Pipeline {
public:
  typedef ExtPxSubchunk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Nv::Blast::Serialization::PxTransform::Pipeline getTransform();
  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Pipeline getGeometry();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PxConvexMeshGeometry::Reader {
public:
  typedef PxConvexMeshGeometry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasScale() const;
  inline  ::Nv::Blast::Serialization::PxMeshScale::Reader getScale() const;

  inline bool hasConvexMesh() const;
  inline  ::capnp::Data::Reader getConvexMesh() const;

  inline  ::uint8_t getMeshFlags() const;

  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PxConvexMeshGeometry::Builder {
public:
  typedef PxConvexMeshGeometry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasScale();
  inline  ::Nv::Blast::Serialization::PxMeshScale::Builder getScale();
  inline void setScale( ::Nv::Blast::Serialization::PxMeshScale::Reader value);
  inline  ::Nv::Blast::Serialization::PxMeshScale::Builder initScale();
  inline void adoptScale(::capnp::Orphan< ::Nv::Blast::Serialization::PxMeshScale>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxMeshScale> disownScale();

  inline bool hasConvexMesh();
  inline  ::capnp::Data::Builder getConvexMesh();
  inline void setConvexMesh( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initConvexMesh(unsigned int size);
  inline void adoptConvexMesh(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownConvexMesh();

  inline  ::uint8_t getMeshFlags();
  inline void setMeshFlags( ::uint8_t value);

  inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type getType();
  inline void setType( ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PxConvexMeshGeometry::Pipeline {
public:
  typedef PxConvexMeshGeometry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Nv::Blast::Serialization::PxMeshScale::Pipeline getScale();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PxQuat::Reader {
public:
  typedef PxQuat Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

  inline float getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PxQuat::Builder {
public:
  typedef PxQuat Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

  inline float getW();
  inline void setW(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PxQuat::Pipeline {
public:
  typedef PxQuat Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PxMeshScale::Reader {
public:
  typedef PxMeshScale Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasScale() const;
  inline  ::Nv::Blast::Serialization::PxVec3::Reader getScale() const;

  inline bool hasRotation() const;
  inline  ::Nv::Blast::Serialization::PxQuat::Reader getRotation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PxMeshScale::Builder {
public:
  typedef PxMeshScale Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasScale();
  inline  ::Nv::Blast::Serialization::PxVec3::Builder getScale();
  inline void setScale( ::Nv::Blast::Serialization::PxVec3::Reader value);
  inline  ::Nv::Blast::Serialization::PxVec3::Builder initScale();
  inline void adoptScale(::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3> disownScale();

  inline bool hasRotation();
  inline  ::Nv::Blast::Serialization::PxQuat::Builder getRotation();
  inline void setRotation( ::Nv::Blast::Serialization::PxQuat::Reader value);
  inline  ::Nv::Blast::Serialization::PxQuat::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat> disownRotation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PxMeshScale::Pipeline {
public:
  typedef PxMeshScale Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Nv::Blast::Serialization::PxVec3::Pipeline getScale();
  inline  ::Nv::Blast::Serialization::PxQuat::Pipeline getRotation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PxTransform::Reader {
public:
  typedef PxTransform Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasQ() const;
  inline  ::Nv::Blast::Serialization::PxQuat::Reader getQ() const;

  inline bool hasP() const;
  inline  ::Nv::Blast::Serialization::PxVec3::Reader getP() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PxTransform::Builder {
public:
  typedef PxTransform Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasQ();
  inline  ::Nv::Blast::Serialization::PxQuat::Builder getQ();
  inline void setQ( ::Nv::Blast::Serialization::PxQuat::Reader value);
  inline  ::Nv::Blast::Serialization::PxQuat::Builder initQ();
  inline void adoptQ(::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat> disownQ();

  inline bool hasP();
  inline  ::Nv::Blast::Serialization::PxVec3::Builder getP();
  inline void setP( ::Nv::Blast::Serialization::PxVec3::Reader value);
  inline  ::Nv::Blast::Serialization::PxVec3::Builder initP();
  inline void adoptP(::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3>&& value);
  inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3> disownP();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PxTransform::Pipeline {
public:
  typedef PxTransform Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Nv::Blast::Serialization::PxQuat::Pipeline getQ();
  inline  ::Nv::Blast::Serialization::PxVec3::Pipeline getP();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool ExtPxAsset::Reader::hasAsset() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxAsset::Builder::hasAsset() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::TkAsset::Reader ExtPxAsset::Reader::getAsset() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::TkAsset::Builder ExtPxAsset::Builder::getAsset() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::TkAsset::Pipeline ExtPxAsset::Pipeline::getAsset() {
  return  ::Nv::Blast::Serialization::TkAsset::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ExtPxAsset::Builder::setAsset( ::Nv::Blast::Serialization::TkAsset::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::TkAsset::Builder ExtPxAsset::Builder::initAsset() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ExtPxAsset::Builder::adoptAsset(
    ::capnp::Orphan< ::Nv::Blast::Serialization::TkAsset>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::TkAsset> ExtPxAsset::Builder::disownAsset() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::TkAsset>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ExtPxAsset::Reader::hasChunks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxAsset::Builder::hasChunks() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Reader ExtPxAsset::Reader::getChunks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Builder ExtPxAsset::Builder::getChunks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ExtPxAsset::Builder::setChunks( ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>::Builder ExtPxAsset::Builder::initChunks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void ExtPxAsset::Builder::adoptChunks(
    ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>> ExtPxAsset::Builder::disownChunks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxChunk>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool ExtPxAsset::Reader::hasSubchunks() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxAsset::Builder::hasSubchunks() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Reader ExtPxAsset::Reader::getSubchunks() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Builder ExtPxAsset::Builder::getSubchunks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void ExtPxAsset::Builder::setSubchunks( ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>::Builder ExtPxAsset::Builder::initSubchunks(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void ExtPxAsset::Builder::adoptSubchunks(
    ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>> ExtPxAsset::Builder::disownSubchunks() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Nv::Blast::Serialization::ExtPxSubchunk>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline float ExtPxAsset::Reader::getUniformInitialBondHealth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float ExtPxAsset::Builder::getUniformInitialBondHealth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ExtPxAsset::Builder::setUniformInitialBondHealth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool ExtPxAsset::Reader::hasBondHealths() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxAsset::Builder::hasBondHealths() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float>::Reader ExtPxAsset::Reader::getBondHealths() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float>::Builder ExtPxAsset::Builder::getBondHealths() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void ExtPxAsset::Builder::setBondHealths( ::capnp::List<float>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void ExtPxAsset::Builder::setBondHealths(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float>::Builder ExtPxAsset::Builder::initBondHealths(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void ExtPxAsset::Builder::adoptBondHealths(
    ::capnp::Orphan< ::capnp::List<float>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float>> ExtPxAsset::Builder::disownBondHealths() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline float ExtPxAsset::Reader::getUniformInitialLowerSupportChunkHealth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float ExtPxAsset::Builder::getUniformInitialLowerSupportChunkHealth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ExtPxAsset::Builder::setUniformInitialLowerSupportChunkHealth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool ExtPxAsset::Reader::hasSupportChunkHealths() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxAsset::Builder::hasSupportChunkHealths() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<float>::Reader ExtPxAsset::Reader::getSupportChunkHealths() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::List<float>::Builder ExtPxAsset::Builder::getSupportChunkHealths() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void ExtPxAsset::Builder::setSupportChunkHealths( ::capnp::List<float>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline void ExtPxAsset::Builder::setSupportChunkHealths(::kj::ArrayPtr<const float> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<float>::Builder ExtPxAsset::Builder::initSupportChunkHealths(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void ExtPxAsset::Builder::adoptSupportChunkHealths(
    ::capnp::Orphan< ::capnp::List<float>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<float>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<float>> ExtPxAsset::Builder::disownSupportChunkHealths() {
  return ::capnp::_::PointerHelpers< ::capnp::List<float>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline  ::uint32_t ExtPxChunk::Reader::getFirstSubchunkIndex() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ExtPxChunk::Builder::getFirstSubchunkIndex() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void ExtPxChunk::Builder::setFirstSubchunkIndex( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t ExtPxChunk::Reader::getSubchunkCount() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t ExtPxChunk::Builder::getSubchunkCount() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void ExtPxChunk::Builder::setSubchunkCount( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool ExtPxChunk::Reader::getIsStatic() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool ExtPxChunk::Builder::getIsStatic() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void ExtPxChunk::Builder::setIsStatic(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool ExtPxSubchunk::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxSubchunk::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxTransform::Reader ExtPxSubchunk::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxTransform::Builder ExtPxSubchunk::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxTransform::Pipeline ExtPxSubchunk::Pipeline::getTransform() {
  return  ::Nv::Blast::Serialization::PxTransform::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void ExtPxSubchunk::Builder::setTransform( ::Nv::Blast::Serialization::PxTransform::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxTransform::Builder ExtPxSubchunk::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void ExtPxSubchunk::Builder::adoptTransform(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxTransform>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxTransform> ExtPxSubchunk::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxTransform>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool ExtPxSubchunk::Reader::hasGeometry() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool ExtPxSubchunk::Builder::hasGeometry() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Reader ExtPxSubchunk::Reader::getGeometry() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Builder ExtPxSubchunk::Builder::getGeometry() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Pipeline ExtPxSubchunk::Pipeline::getGeometry() {
  return  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void ExtPxSubchunk::Builder::setGeometry( ::Nv::Blast::Serialization::PxConvexMeshGeometry::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Builder ExtPxSubchunk::Builder::initGeometry() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void ExtPxSubchunk::Builder::adoptGeometry(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxConvexMeshGeometry>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxConvexMeshGeometry> ExtPxSubchunk::Builder::disownGeometry() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxConvexMeshGeometry>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PxConvexMeshGeometry::Reader::hasScale() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PxConvexMeshGeometry::Builder::hasScale() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxMeshScale::Reader PxConvexMeshGeometry::Reader::getScale() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxMeshScale::Builder PxConvexMeshGeometry::Builder::getScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxMeshScale::Pipeline PxConvexMeshGeometry::Pipeline::getScale() {
  return  ::Nv::Blast::Serialization::PxMeshScale::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PxConvexMeshGeometry::Builder::setScale( ::Nv::Blast::Serialization::PxMeshScale::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxMeshScale::Builder PxConvexMeshGeometry::Builder::initScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PxConvexMeshGeometry::Builder::adoptScale(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxMeshScale>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxMeshScale> PxConvexMeshGeometry::Builder::disownScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxMeshScale>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PxConvexMeshGeometry::Reader::hasConvexMesh() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PxConvexMeshGeometry::Builder::hasConvexMesh() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader PxConvexMeshGeometry::Reader::getConvexMesh() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder PxConvexMeshGeometry::Builder::getConvexMesh() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PxConvexMeshGeometry::Builder::setConvexMesh( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder PxConvexMeshGeometry::Builder::initConvexMesh(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PxConvexMeshGeometry::Builder::adoptConvexMesh(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> PxConvexMeshGeometry::Builder::disownConvexMesh() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint8_t PxConvexMeshGeometry::Reader::getMeshFlags() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t PxConvexMeshGeometry::Builder::getMeshFlags() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PxConvexMeshGeometry::Builder::setMeshFlags( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type PxConvexMeshGeometry::Reader::getType() const {
  return _reader.getDataField< ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type PxConvexMeshGeometry::Builder::getType() {
  return _builder.getDataField< ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PxConvexMeshGeometry::Builder::setType( ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type value) {
  _builder.setDataField< ::Nv::Blast::Serialization::PxConvexMeshGeometry::Type>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float PxQuat::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float PxQuat::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PxQuat::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float PxQuat::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float PxQuat::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PxQuat::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float PxQuat::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float PxQuat::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PxQuat::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float PxQuat::Reader::getW() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float PxQuat::Builder::getW() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void PxQuat::Builder::setW(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool PxMeshScale::Reader::hasScale() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PxMeshScale::Builder::hasScale() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxVec3::Reader PxMeshScale::Reader::getScale() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxVec3::Builder PxMeshScale::Builder::getScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxVec3::Pipeline PxMeshScale::Pipeline::getScale() {
  return  ::Nv::Blast::Serialization::PxVec3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PxMeshScale::Builder::setScale( ::Nv::Blast::Serialization::PxVec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxVec3::Builder PxMeshScale::Builder::initScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PxMeshScale::Builder::adoptScale(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3> PxMeshScale::Builder::disownScale() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PxMeshScale::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PxMeshScale::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxQuat::Reader PxMeshScale::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxQuat::Builder PxMeshScale::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxQuat::Pipeline PxMeshScale::Pipeline::getRotation() {
  return  ::Nv::Blast::Serialization::PxQuat::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PxMeshScale::Builder::setRotation( ::Nv::Blast::Serialization::PxQuat::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxQuat::Builder PxMeshScale::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PxMeshScale::Builder::adoptRotation(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat> PxMeshScale::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PxTransform::Reader::hasQ() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PxTransform::Builder::hasQ() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxQuat::Reader PxTransform::Reader::getQ() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxQuat::Builder PxTransform::Builder::getQ() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxQuat::Pipeline PxTransform::Pipeline::getQ() {
  return  ::Nv::Blast::Serialization::PxQuat::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PxTransform::Builder::setQ( ::Nv::Blast::Serialization::PxQuat::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxQuat::Builder PxTransform::Builder::initQ() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PxTransform::Builder::adoptQ(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxQuat> PxTransform::Builder::disownQ() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxQuat>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PxTransform::Reader::hasP() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PxTransform::Builder::hasP() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Nv::Blast::Serialization::PxVec3::Reader PxTransform::Reader::getP() const {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Nv::Blast::Serialization::PxVec3::Builder PxTransform::Builder::getP() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Nv::Blast::Serialization::PxVec3::Pipeline PxTransform::Pipeline::getP() {
  return  ::Nv::Blast::Serialization::PxVec3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PxTransform::Builder::setP( ::Nv::Blast::Serialization::PxVec3::Reader value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Nv::Blast::Serialization::PxVec3::Builder PxTransform::Builder::initP() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PxTransform::Builder::adoptP(
    ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3>&& value) {
  ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Nv::Blast::Serialization::PxVec3> PxTransform::Builder::disownP() {
  return ::capnp::_::PointerHelpers< ::Nv::Blast::Serialization::PxVec3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace
}  // namespace

#endif  // CAPNP_INCLUDED_f4df9a42d5842b01_
